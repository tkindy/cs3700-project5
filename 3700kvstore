#!/usr/bin/python3

from enum import Enum
from json import dumps, loads
from random import uniform
from select import select
from socket import AF_UNIX, SOCK_SEQPACKET, socket
from sys import argv
from time import time

# Socket receive timeout, in seconds
RECV_TIMEOUT = 0.01
# Maximum number of bytes to receive at once
MAX_RECEIVE_BYTES = 2 ** 16
# Random election timeout interval, in seconds
ELECTION_TIMEOUT_INTERVAL = (0.25, 0.5)
# Maximum time between leader heartbeats, in seconds
HEARTBEAT_INTERVAL = ELECTION_TIMEOUT_INTERVAL[0] / 2
# Maximum number of entries to send a follower in one request
MAX_APPEND_ENTRIES = 25

# Receivable message types (these need handlers)
GET = 'get'
PUT = 'put'
REQ_VOTE = 'request_vote'
VOTE = 'vote'
APPEND = 'append_entries'
OK = 'ok'
FAIL = 'fail'

# Other message types
REDIRECT = 'redirect'

# Dummy log entry
DUMMY_ENTRY = {
    'index': -1,
    'term': -1,
    'key': '',
    'value': ''
}


class State(Enum):
    """The server state."""
    LEADER = 1
    CANDIDATE = 2
    FOLLOWER = 3


class KVStore(object):
    def __init__(self, my_id: str, replica_ids: list):
        self.my_id = my_id
        self.replica_ids = replica_ids
        self.majority = (len(replica_ids) + 1) // 2 + 1

        self.sock = self.build_socket()

        self.state = State.FOLLOWER
        self.term = 0
        self.leader = 'FFFF'

        self.votes = 0
        self.voted_for = None

        self.timeout = None
        self.reset_timeout()

        self.log = []
        self.data = {}
        self.next_indices = {replica_id: 0 for replica_id in self.replica_ids}
        self.committed = -1

        self.leader_handlers = {
            GET: self.get_key,
            PUT: self.put_key,
            REQ_VOTE: self.drop_message,
            VOTE: self.drop_message,
            APPEND: self.drop_message,
            OK: self.confirm_replication,
            FAIL: self.fail_replication
        }

        self.candidate_handlers = {
            GET: self.fail_request,
            PUT: self.fail_request,
            REQ_VOTE: self.drop_message,
            VOTE: self.count_vote,
            APPEND: self.drop_out,
            OK: self.drop_message,
            FAIL: self.drop_message
        }

        self.follower_handlers = {
            GET: self.redirect_request,
            PUT: self.redirect_request,
            REQ_VOTE: self.cast_vote,
            VOTE: self.drop_message,
            APPEND: self.append_entries,
            OK: self.drop_message,
            FAIL: self.drop_message
        }

    def build_socket(self):
        """Build the UNIX domain socket."""
        sock = socket(AF_UNIX, SOCK_SEQPACKET)
        sock.connect(self.my_id)

        return sock

    def get_key(self, msg: dict):
        if msg['key'] in self.data:
            resp = self.build_base_response(msg, OK)
            resp['value'] = self.data[msg['key']]
            self.send_message(resp)
        else:
            self.send_message(self.build_base_response(msg, FAIL))

    def put_key(self, msg: dict):
        self.log.append({
            'src': msg['src'],
            'MID': msg['MID'],
            'index': len(self.log),
            'term': self.term,
            'key': msg['key'],
            'value': msg['value']
        })

        self.send_appends()

    def confirm_replication(self, msg: dict):
        self.next_indices[msg['src']] = msg['next_index']

    def fail_replication(self, msg: dict):
        self.next_indices[msg['src']] -= 1

    def fail_request(self, msg: dict):
        """Send a failed response to the requester."""
        self.send_message(self.build_base_response(msg, FAIL))

    def drop_message(self, msg: dict):
        """Drop the given message."""
        pass

    def run(self):
        """Run the key-value store."""
        while True:
            self.receive_message()

            if self.state is State.LEADER:
                self.commit_entries()

            if self.timed_out():
                if self.state is State.LEADER:
                    self.send_appends()
                elif self.state in [State.CANDIDATE, State.FOLLOWER]:
                    self.start_election()
                else:
                    self.invalid_state()

    def commit_entries(self):
        nexts = list(self.next_indices.values())
        nexts.sort(reverse=True)
        new_committed = nexts[self.majority - 2] - 1

        for entry in self.log[self.committed + 1:new_committed + 1]:
            self.data[entry['key']] = entry['value']
            self.send_message(self.build_base_response({'src': entry['src'], 'MID': entry['MID']}, OK))

        self.committed = new_committed

    def timed_out(self) -> bool:
        return self.timeout - time() <= 0

    def start_election(self):
        self.term += 1
        self.state = State.CANDIDATE
        self.voted_for = self.my_id
        self.votes = 1

        self.reset_timeout()

        for replica_id in self.replica_ids:
            req = self.build_base_message(replica_id, REQ_VOTE)
            prev_entry = self.log[-1] if self.log else DUMMY_ENTRY
            req['prev_index'] = prev_entry['index']
            req['prev_term'] = prev_entry['term']

            self.send_message(req)

    def count_vote(self, msg: dict):  # Parameter unused, but required to match interface
        self.votes += 1

        if self.votes >= self.majority:
            self.state = State.LEADER
            self.leader = self.my_id
            self.reset_votes()

            self.next_indices = {replica_id: len(self.log) for replica_id in self.replica_ids}

            self.send_appends()

    def send_appends(self):
        self.reset_timeout()

        for replica_id in self.replica_ids:
            msg = self.build_base_message(replica_id, APPEND)

            next_index = self.next_indices[replica_id]
            prev_index = next_index - 1
            prev_entry = self.log[prev_index] if prev_index >= 0 else DUMMY_ENTRY

            msg['prev_index'] = prev_index
            msg['prev_term'] = prev_entry['term']
            msg['entries'] = self.log[next_index:next_index + MAX_APPEND_ENTRIES]
            msg['committed'] = self.committed

            self.send_message(msg)

    def append_entries(self, msg: dict):
        if msg['term'] > self.term:
            self.set_term(msg['term'])
            self.leader = msg['leader']

            self.reset_timeout()

        elif msg['term'] == self.term:
            self.reset_timeout()
            prev_index = msg['prev_index']

            if prev_index == -1 or \
                    (len(self.log) - 1 >= prev_index and self.log[prev_index]['term'] == msg['prev_term']):
                self.log = self.log[:prev_index + 1]
                self.log += msg['entries']

                resp = self.build_base_message(self.leader, OK)
                resp['next_index'] = len(self.log)
                self.send_message(resp)
            else:
                self.send_message(self.build_base_message(self.leader, FAIL))

            new_committed = min(msg['committed'], len(self.log) - 1)

            for entry in self.log[self.committed + 1:new_committed + 1]:
                self.data[entry['key']] = entry['value']

            self.committed = new_committed

        else:
            self.drop_message(msg)

    def drop_out(self, msg: dict):
        if msg['term'] >= self.term:
            self.set_term(msg['term'])
            self.state = State.FOLLOWER
            self.leader = msg['src']

    def set_term(self, term: int):
        self.term = term
        self.reset_votes()

    def reset_votes(self):
        self.voted_for = None
        self.votes = 0

    def redirect_request(self, msg: dict):
        self.send_message(self.build_base_response(msg, REDIRECT))

    def cast_vote(self, msg: dict):
        self.reset_timeout()
        prev_entry = self.log[-1] if self.log else DUMMY_ENTRY
        prev_term = prev_entry['term']
        prev_index = prev_entry['index']

        if msg['term'] >= self.term and \
                (not self.voted_for or self.voted_for == msg['src']) and \
                (msg['prev_term'] > prev_term or
                 (msg['prev_term'] == prev_term and
                  msg['prev_index'] >= prev_index)):
            self.voted_for = msg['src']
            self.send_message(self.build_base_message(msg['src'], VOTE))

    def reset_timeout(self):
        """Reset the timeout."""
        if self.state is State.LEADER:
            self.timeout = time() + HEARTBEAT_INTERVAL
        elif self.state in [State.CANDIDATE, State.FOLLOWER]:
            self.timeout = time() + uniform(ELECTION_TIMEOUT_INTERVAL[0], ELECTION_TIMEOUT_INTERVAL[1])
        else:
            self.invalid_state()

    def receive_message(self):
        """Receive and handle a message from the socket."""
        ready = select([self.sock], [], [], RECV_TIMEOUT)[0]

        if ready:
            msg_raw = self.sock.recv(MAX_RECEIVE_BYTES)

            if not msg_raw:
                return

            msg = loads(msg_raw.decode('utf-8'))
            msg_t = msg['type']

            if self.state is State.LEADER:
                self.leader_handlers[msg_t](msg)
            elif self.state is State.CANDIDATE:
                self.candidate_handlers[msg_t](msg)
            elif self.state is State.FOLLOWER:
                self.follower_handlers[msg_t](msg)
            else:
                self.invalid_state()

    def invalid_state(self):
        """Throw an error for an invalid state."""
        raise RuntimeError('Invalid state: {}'.format(self.state))

    def build_base_response(self, msg: dict, msg_type: str) -> dict:
        """Build a response to the message."""
        resp = self.build_base_message(msg['src'], msg_type)
        resp['MID'] = msg['MID']
        return resp

    def build_base_message(self, dest: str, msg_type: str) -> dict:
        """Build the base message."""
        return {
            'src': self.my_id,
            'dst': dest,
            'term': self.term,
            'leader': self.leader,
            'type': msg_type
        }

    def send_message(self, msg: dict):
        """Send a message through the socket."""
        self.sock.send(dumps(msg).encode('utf-8'))

    def debug(self, msg: str):
        print('<{}> {}'.format(self.my_id, msg))


if __name__ == '__main__':
    KVStore(argv[1], argv[2:]).run()
