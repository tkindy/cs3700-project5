#!/usr/bin/python3

from enum import Enum
from json import dumps, loads
from random import uniform
from select import select
from socket import AF_UNIX, SOCK_SEQPACKET, socket
from sys import argv
from time import time

# CONSTANTS
# Timeout for the call to select, in seconds
SELECT_TIMEOUT = 0.1
# Maximum amount of data to receive from the socket, in bytes
MAX_BYTES = 2 ** 15
# Inclusive election timeout bounds (min, max), in seconds
ELECT_TO_BOUNDS = (1, 2)

# Message type constants
GET = 'get'
PUT = 'put'
REQ_VOTE = 'request_vote'
VOTE = 'vote'
APPEND = 'append_entries'

REDIRECT = 'redirect'

# DERIVED CONSTANTS
# Leader heartbeat interval, in seconds
HEARTBEAT_INTERVAL = ELECT_TO_BOUNDS[0] / 10


class State(Enum):

    """Server states"""
    FOLLOWER = 1
    CANDIDATE = 2
    LEADER = 3


class KVStore(object):

    """The key-value store program."""

    def __init__(self, my_id: str, replica_ids: list):
        self.my_id = my_id
        self.replica_ids = replica_ids

        self.data = {}

        self.sock = self.build_socket()
        self.state = State.FOLLOWER
        self.leader = 'FFFF'
        self.term = 0

        self.reset_timeout()

        self.voted_for = None
        self.votes = 0

        self.leader_handlers = {
            GET: self.handle_get,
            PUT: self.handle_put,
            REQ_VOTE: self.drop_message,
            VOTE: self.drop_message,
            APPEND: self.handle_entries
        }

        self.candidate_handlers = {
            GET: self.drop_message,  # TODO should queue request until new leader is decided
            PUT: self.drop_message,  # TODO should queue request until new leader is decided
            REQ_VOTE: self.drop_message,
            VOTE: self.tally_vote,
            APPEND: self.handle_entries
        }

        self.follower_handlers = {
            GET: self.redirect_request,
            PUT: self.redirect_request,
            REQ_VOTE: self.cast_vote,
            VOTE: self.drop_message,
            APPEND: self.handle_entries
        }

    def build_socket(self):
        """Build the UNIX domain socket."""
        sock = socket(AF_UNIX, SOCK_SEQPACKET)
        sock.connect(self.my_id)

        return sock

    def reset_timeout(self):
        if self.state in [State.CANDIDATE, State.FOLLOWER]:
            timeout_len = uniform(ELECT_TO_BOUNDS[0], ELECT_TO_BOUNDS[1])
            print("{} will timeout in {} seconds".format(self.my_id, timeout_len))
            self.timeout = time() + timeout_len

        elif self.state is State.LEADER:
            self.timeout = time() + HEARTBEAT_INTERVAL

        else:
            self.unknown_state()

    def run(self):
        """Run the key-value store."""
        while True:
            print("{}: {}".format(self.my_id, self.leader))
            if self.timeout - time() <= 0:
                if self.state in [State.CANDIDATE, State.FOLLOWER]:
                    self.start_election()

                elif self.state is State.LEADER:
                    self.append_entries([])

                else:
                    self.unknown_state()

            self.handle_message()

    def start_election(self):
        print("{} initiating election".format(self.my_id))

        self.term += 1
        self.state = State.CANDIDATE
        self.leader = 'FFFF'
        self.votes = 1  # start by voting for yourself

        self.request_votes()

    def request_votes(self):
        for replica_id in self.replica_ids:
            msg = self.build_base_message(replica_id, REQ_VOTE)
            self.send_message(msg)

        self.reset_timeout()

    def handle_message(self):
        ready = select([self.sock], [], [], SELECT_TIMEOUT)[0]

        if ready:
            msg_raw = self.sock.recv(MAX_BYTES)

            if not msg_raw:
                return

            msg = loads(msg_raw.decode('utf-8'))
            msg_t = msg['type']

            print('{} received {} msg from {}'.format(
                self.my_id, msg_t, msg['src']))

            if self.state is State.LEADER:
                self.leader_handlers[msg_t](msg)
            elif self.state is State.CANDIDATE:
                self.candidate_handlers[msg_t](msg)
            elif self.state is State.FOLLOWER:
                if msg['src'] == self.leader:
                    self.reset_timeout()

                self.follower_handlers[msg_t](msg)
            else:
                self.unknown_state()

    def handle_get(self, req: dict):
        if req['key'] in self.data:
            msg = self.build_base_response(req, 'ok')
            msg['value'] = self.data[req['key']]

            self.send_message(msg)

        else:
            self.fail_request(req)

    def handle_put(self, req: dict):
        self.data[req['key']] = req['value']

        msg = self.build_base_response(req, 'ok')
        self.send_message(msg)

    def fail_request(self, req: dict):
        msg = self.build_base_response(req, 'fail')
        self.send_message(msg)

    def redirect_request(self, req: dict):
        msg = self.build_base_response(req, REDIRECT)
        self.send_message(msg)

    def tally_vote(self, msg: dict):
        if msg['vote'] == self.my_id:
            self.votes += 1

        if self.votes >= (len(self.replica_ids) + 1) // 2 + 1:
            self.inaugurate()

    def inaugurate(self):
        self.state = State.LEADER
        self.set_leader(self.my_id)

        print('{} is now leader'.format(self.my_id))
        self.append_entries([])

    def append_entries(self, entries: list):
        self.reset_timeout()

        for replica_id in self.replica_ids:
            msg = self.build_base_message(replica_id, APPEND)
            msg['entries'] = entries

            self.send_message(msg)

    def handle_entries(self, msg: dict):
        if self.state is State.LEADER:
            self.drop_message(msg)

        elif self.state is State.CANDIDATE:
            if msg['term'] >= self.term:
                self.state = State.FOLLOWER
                self.term = msg['term']
                self.set_leader(msg['src'])

                print("{} recognizing {} as leader".format(self.my_id, self.leader))

                self.handle_entries(msg)

        elif self.state is State.FOLLOWER:
            if msg['term'] >= self.term:
                self.term = msg['term']

                if msg['leader'] != self.leader:
                    self.set_leader(msg['leader'])
                    print("{} recognizing {} as leader".format(self.my_id, self.leader))

        else:
            self.unknown_state()

    def set_leader(self, leader: str):
        self.leader = leader
        self.reset_timeout()

    def cast_vote(self, req: dict):
        if self.voted_for is None:
            self.voted_for = req['src']

        msg = self.build_base_message(req['src'], VOTE)
        msg['vote'] = self.voted_for

        self.send_message(msg)

    def build_base_response(self, req: dict, msg_type: str) -> dict:
        resp = self.build_base_message(req['src'], msg_type)
        resp['MID'] = req['MID']

        return resp

    def build_base_message(self, dst: str, msg_type: str) -> dict:
        return {
            'src': self.my_id,
            'dst': dst,
            'leader': self.leader,
            'term': self.term,
            'type': msg_type
        }

    def send_message(self, msg: dict):
        """Send the message as JSON."""
        print('{} sending {} msg to {}'.format(
            msg['src'], msg['type'], msg['dst']))
        self.sock.send(dumps(msg).encode('utf-8'))

    def drop_message(self, msg: dict):
        print('{} dropping {} msg from {}'.format(
            self.my_id, msg['type'], msg['src']))

    def unknown_state(self):
        raise RuntimeError("Unknown state '{}'".format(self.state))


if __name__ == '__main__':
    KVStore(argv[1], argv[2:]).run()
